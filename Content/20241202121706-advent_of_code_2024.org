:PROPERTIES:
:ID:       c5c4cca7-8b5a-4a89-b6f9-93c039a09ee0
:END:
#+title: Advent of Code 2024
#+filetags: :project:

* Day 5
#+begin_src lisp
(ql:quickload :uiop)
(ql:quickload :alexandria)
(ql:quickload :cl-ppcre)

(defun parse-input (input-file)
  (let* ((parsed (cl-ppcre:split "\\n\\n" (uiop:read-file-string input-file)))
         (edges (cl-ppcre:split "\\n" (car parsed)))
         (updates (cl-ppcre:split "\\n" (cadr parsed))))
    (list edges updates)))

(defun gen-hash-manager ()
  (let ((hsh (make-hash-table)))
    #'(lambda (message)
        (cond ((eq message 'reset)
               #'(lambda ()
                   (clrhash hsh)))
              ((eq message 'table)
               #'(lambda ()
                   hsh))
              ((eq message 'insert)
               #'(lambda (key val)
                   (let ((existing (gethash key hsh)))
                     (if existing
                         (setf (gethash key hsh) (cons val existing))
                         (setf (gethash key hsh) (list val))))))
              ((eq message 'fetch)
               #'(lambda (key)
                   (gethash key hsh)))
              (t (error message "invalid message received"))))))

(defvar hasher (gen-hash-manager))

(defun insert (key val)
  (funcall (funcall hasher 'insert) key val))

(defun fetch (key)
  (funcall (funcall hasher 'fetch) key))

(defun build-hash (edges)
  (dolist (edge edges)
    (let ((split (cl-ppcre:split #\| edge)))
      (insert (parse-integer (cadr split))
              (parse-integer (car split))))))

(defvar input (parse-input "input.txt"))

(build-hash (car input))

(defun check-update (update)
  (let ((update (mapcar #'parse-integer update))
        (mid (ceiling (/ (length update)
                       2)))
        (middle nil))
    (do ((curr (car update) (car tail))
         (tail (cdr update) (cdr tail))
         (i 1 (+ i 1)))
        ((not tail) middle)
      (when (= i mid)
        (setf middle curr))
      (when (intersection tail (fetch curr))
        (return nil)))))

(defun solve-p1 ()
  (reduce #'(lambda (acc curr)
              (+ acc (if curr curr 0)))
          (mapcar #'check-update (mapcar (alexandria:curry #'cl-ppcre:split #\,) (cadr input)))
          :initial-value 0))

;; part 2

(defun insert-at-index (list element index)
  (if (zerop index)
      (cons element list)
      (let ((head (subseq list 0 index))
            (tail (nthcdr index list)))
        (append head (list element) tail))))

(defun curtail (curr tail intsction)
  (let ((fixes (insert-at-index tail
                                curr
                                (1+ (apply #'max
                                           (mapcar #'(lambda (ele)
                                                       (position ele tail))
                                                   intsction))))))
    (values (car fixes) (cdr fixes))))


(defun check-fixed-update (update)
  (let ((update (mapcar #'parse-integer update))
        (mid (ceiling (/ (length update)
                         2)))
        (fix-flag nil)
        (middle nil))
    (do ((curr (car update) (car tail))
         (tail (cdr update) (cdr tail))
         (i 1 (+ i 1)))
        ((not tail) (when fix-flag middle))
      (tagbody
         start
         (let ((intsction (intersection tail (fetch curr))))
           (when intsction
             (setf fix-flag t)
             (multiple-value-bind (cr tl)
                 (curtail curr tail intsction)
               (setf curr cr
                     tail tl))
             (go start)))
         (when (= i mid)
           (setf middle curr))))))

(defun solve-p2 ()
  (reduce #'(lambda (acc curr)
              (print curr)
              (+ acc (if curr curr 0)))
          (mapcar #'check-fixed-update (mapcar (alexandria:curry #'cl-ppcre:split #\,) (cadr input)))
          :initial-value 0))
#+end_src
* Day 4
#+begin_src lisp
;; for each cell, check 8 directions
;; checking in a direction can be generically identified as an accumulated past state and the stepper function
;; the stepper functions will then be 8 of them ranging cartesian product of +1,-1,0 for x,y except 0,0 (9-1)
;; can build steppers dynamically with macros


;; the checker actually uses a stepper func, has the current state and has the knowledge of the state machine baked in

(ql:quickload :uiop)
(ql:quickload :alexandria)

(defvar input (uiop:read-file-lines "input.txt"))

(defun gen-util-funcs (arr)
  (macrolet ((in? (i low high)
               `(and (< ,i ,high)
                     (>= ,i ,low))))
    (let ((rows (length arr))
          (cols (length (car arr)))
          (utils (make-hash-table)))
      (setf (gethash :idx utils )
            (lambda (i j)
                ;; indexer
                (aref (nth i arr) j)))
      (setf (gethash :chk utils)
            (lambda (i j)
                ;; validity checker
                (and (in? i 0 rows)
                     (in? j 0 cols))))
      utils)))

(defvar utils (gen-util-funcs input))

(defun fetch (i j)
  (when (funcall (gethash :chk utils) i j)
    (funcall (gethash :idx utils) i j)))

(defun build-stepper (steps)
  #'(lambda (x y)
      (list (+ x (car steps))
            (+ y (cadr steps)))))

(defvar steppers
  (cdr (mapcar #'build-stepper
               (loop for x in
                           (list 0 1 -1)
                     nconc
                     (loop for y in
                                 (list 0 1 -1)
                           collect (list x y)))) ))

(defun checker (i j stepper req)
  (labels ((iter-check (x y req-i)
             (let ((fetched (fetch x y))
                   (lreq (length req)))
               (cond ((= req-i lreq)
                      t)
                     ((not fetched)
                      nil)
                     ((equal fetched (aref req req-i))
                      (apply #'iter-check (append (funcall stepper x y) (list (+ 1 req-i)))))))))
    (iter-check i j 0)))


(defun collate-checks (i j req)
  (count 't (mapcar #'(lambda (stepper)
                        (checker i j stepper req))
                    steppers)))

(defun solve-p1 (req)
  (let ((acc 0))
    (dolist (i (alexandria:iota (length input)))
      (dolist (j (alexandria:iota (length (car input))))
        (incf acc (collate-checks i j req))))
    acc))


;; part 2
;; approach still the same via specific steppers, just validator can be monolithic

(defun check-X-MAS (i j)
  (when (equal (fetch i j) #\A)
    (and (eval `(or ,@(mapcar (alexandria:curry
                         #'checker (1- i) (1- j) (build-stepper (list 1 1)))
                        (list "MAS" "SAM"))))
         (eval `(or ,@(mapcar (alexandria:curry
                              #'checker (1+ i) (1- j) (build-stepper (list -1 1)))
                             (list "MAS" "SAM")))))))


(defun solve-p2 ()
  (let ((acc 0))
    (dolist (i (alexandria:iota (1- (length input)) :start 1))
      (dolist (j (alexandria:iota (1- (length (car input))) :start 1))
        (when (check-x-mas i j)
          (incf acc 1))))
    acc))
#+end_src

* Day 3
#+begin_src lisp
(ql:quickload :uiop)
(ql:quickload :cl-ppcre)

(defvar input (read-file-to-string "input"))

;; part 1

(defun extract-mul-parameters (input-string)
        (multiple-value-bind (matched-p matches)
                (cl-ppcre:scan-to-strings "mul\\((\\d+),(\\d+)\\)" input-string)
            (when matched-p
                    matches)))

(defun parse-mul (match)
        (let* ((parse-vec (extract-mul-parameters match))
                    (n1 (parse-integer (svref parse-vec 0)))
                    (n2 (parse-integer (svref parse-vec 1))))
            (* n1 n2)))

(defun solve-p1 (input)
        (apply #'+ (mapcar #'parse-mul
                                (cl-ppcre:all-matches-as-strings
                                    "mul\\((\\d+),(\\d+)\\)"
                                        input))))
;; part 2

(defun solve-p2 (input)
        (let ((do? t)
                (acc 0))
            (dolist (state (cl-ppcre:all-matches-as-strings
                                "mul\\((\\d+),(\\d+)\\)|do\\(\\)|don't\\(\\)"
                                    input)
                                acc)
                    (cond ((equal state "do()") (setf do? t))
                            ((equal state "don't()") (setf do? nil))
                                (t (when do?
                                            (incf acc (parse-mul state))))))))
#+end_src
* Day 2

#+begin_src lisp
(defvar test-input
  '((7 6 4 2 1)
    (1 2 7 8 9)
    (9 7 6 2 1)
    (1 3 2 4 5)
    (8 6 4 4 1)
    (1 3 6 7 9)))

(defun transit-diff-set (report)
  (let ((len (length report)))
    (remove-duplicates (mapcar #'(lambda (n-1 n)
                                   (- n n-1))
                               (subseq report 0 (- len 1))
                               (subseq report 1 len)) )))

(defun dampened-val-report (report)
  (if (val-report report)
      1
      (do ((i 0 (+ 1 i)))
          ((= i (length report)) 0)
        (let ((candidate (append
                          (subseq report 0 i)
                          (subseq report (+ i 1) (length report)))))
          (when (val-report candidate)
            (return 1))))))

(defun val-report (report)
  (let* ((diffs (transit-diff-set report))
         (abs-diffs (remove-duplicates (mapcar #'abs diffs))))
    (cond ((find 0 abs-diffs )  nil)
          ((> (apply #'max abs-diffs) 3) nil)
          ((= (length (remove-duplicates (mapcar #'signum diffs))) 2) nil)
          (t 1))))

(defun safe-reports (input)
  (apply #'+ (mapcar #'dampened-val-report input)))
#+end_src

* Day 1

#+begin_src lisp
(ql:quickload :alexandria)

(defvar test-input
  '((3   4)
    (4   3)
    (2   5)
    (1   3)
    (3   9)
    (3   3)))

;;
;; Part 1
(defmacro parse-sort (selector input)
  (let ((ele (gensym)))
    `(sort (mapcar #'(lambda (,ele)
                       (coerce (,selector ,ele) 'integer))
                   ,input)
      #'>)))


(defun add-abs-diff-solver (input)
 (apply #'+ (mapcar (lambda (x y) (abs (- x y) ))
                       (parse-sort car input)
                       (parse-sort cadr input))))

;; Part 2
;;

(defun build-hash (lis table)
  (labels ((increment-hash (ele)
             (if (gethash ele table)
                 (incf (gethash ele table) 1)
                 (setf (gethash ele table) 1))))
    (mapcar #'increment-hash lis)))

(defun built-hash (lis)
  (let ((hash (make-hash-table)))
    (build-hash lis hash)
    hash))

(defun freq-mul-add-solver (input)
  (let ((h-a (built-hash (parse-sort car input)))
        (h-b (built-hash (parse-sort cadr input)))
        (acc 0))
    (dolist (ka (alexandria:hash-table-keys h-a)
                acc)
      (incf acc (if (gethash ka h-b)
                 (* (gethash ka h-a)
                    (gethash ka h-b)
                    ka)
                 0)))))
#+end_src
