:PROPERTIES:
:ID:       0643a384-27d4-41c3-963b-a8b1d84c8c6b
:ROAM_REFS: @germain_termite_nodate
:END:
#+title: Termite: Dist. Lisp
#+filetags: :lisp:

* Flowing Phrasal Outline
** Isolated Sequential Processes
*** Memory Space Isolation
*** Node and Process Identifiers
*** Process Spawning
** Sending and Receiving messages
*** Process Mailbox
*** [[id:b2ce2739-98c4-4ff0-931c-3a836686bf55][Async]] Message Sends
*** Sync Message Recvs
*** spawn and send sample

#+begin_src lisp
(let ((me (self)))
  (spawn
   (! me "hello, world.")))

(?)
#+end_src

 - ! : async send mesg
 - ? : sync (blocking) recv mesg

** Failure
*** Hardware Unreliability
 - the "real world" or the "physical"
*** Sends : Unreliable Operations

** Peripheral Aspects
*** Serialization
 - Data
 - Closures
 - Continuations
**** Non-Serializables -> Addressable Proxies
 - ports -> open files -> processes -> pids
 - processes as pids
*** [[id:efba8f9b-a5df-4212-94c9-230bef916b5c][Immutability]]
*** Suspended Processes as State
*** [[id:34df7d47-1f78-4acf-8dd7-9c03e04e4a9d][Exception Handling]]
**** Dyamically scoped handlers
 - choose : handle or raise again
 - when raise:
   - encapsulating handler invoked
 - Cross Process Exception Transfers upon deaths
   - "send and pray" applies here as well
   - cross process exception raises upon receives


**** Process relations
 - supervisor - worker (two way death effects : work doesn't matter if not supervised)
 - monitor - worker (one way death effect : worker doesn't care if monitor dies)

*** Connecting Nodes
 - Unique identifiers for each node
   - (IP#:port)
   - node references contain these
     - gen with make-node

*** [[id:19079639-be92-46cf-82c5-3d81c935705c][Remote Procedure Calls]]
*** [[id:f6111cb3-60df-422e-aca3-c4cb1b5cbb2a][Process Migration]]
 - Serialize a Continuation
 - send and pray
** Language Overview
*** Making a server
   #+begin_src scheme
(define pong-server
    (spawn
     (let loop ()
          (let ((msg (?)))
            (if (and (list? msg)
                     (= (length msg) 2)
                     (pid? (car msg))
                     (eq? (cadr msg) 'ping))
                (let ((from (car msg)))
                  (! from 'pong)
                  (loop))
                (loop))))))

(! pong-server (list (self) 'ping))     ;; -> send 'ping

(?) ;; -> 'pong
   #+end_src
*** predicate + pattern matches
   #+begin_src scheme
(define better-pong-server
  (spawn
   (let loop ()
     (recv
      ((from 'ping)                     ;pattern to match
       (where (pid? from))              ;additional conditions
       (! from 'pong)))                 ;action
     (loop))))
   #+end_src
*** timeouts
#+begin_src scheme
(recv
 (pattern-match-form predicate-filter-form action-form)
 (after timeout-duration (raise 'timeout)))
#+end_src
*** Remote Procedure Calls
 - !? from the client (sync sends and recvs) -> not just a !

   #+begin_src scheme
(define rpc-server
  (spawn
   (let loop ()
     (recv
      ((from tag ('proc-tag arg))
       (! from (list tag ((fetch-corresponding-proc 'proc-tag) arg))))
      (loop)))))

(let ((tag (make-tag)))
  (! rpc-server (list (self) tag (list 'add 1 2)))

  (recv
   ;; check for same tag from ret
   ((tag result) result)                ;; yields 3
   ))

;; !? -> send and recv like above
;; !? handles tag management -> no explicit need
(!? rpc-server (list 'add 1 2 ))   ;; yields 3
   #+end_src

*** Mutability
 - simulate via let loops
   #+begin_src scheme
(define (make-cell init-content)
  (spawn
   (let loop ((content init-content))
     (recv

      ((from tag 'get)
       (! from (list tag content))
       (loop content))

      (('set! new-content)
       (loop new-content))))))

(define (cell-get cell)
  (!? cell 'get))

(define (cell-set! cell val)
  (! cell (list 'set! val)))
   #+end_src

*** Exception Handling
 - raise -> catch & handle
 - handlers are dynamically scoped
 - (catch dealer ..body) : implements dealer for raises and doesn't continue
 - (handle dealer ..body) : implements dealer for raises and continues exec

   #+begin_src scheme

(catch
  (lambda (exc) exc)
  (some-work) ;; is done
  (raise 'err) ;; returns 'err from here
  (some-more-work) ;; isn't exec'd
  (yield-final-val)) ;; control doesn't reach here

(handle
  (lambda (exc) exc)
  (some-work) ;; is done
  (raise 'err) ;; this form returns err but exec continues
  (some-more-work) ;; is exec'd
  (yield-final-val)) ;; final yield val from here

   #+end_src

 - for interprocess exc transfers, need to use a spawn-link

   #+begin_src scheme
(catch
 (lambda (exc) (list 'transfer-will-fail exc))
 (spawn (raise 'err)) ;; isn't handled cause no interprocess link
 (? 1 'ok) ;; timed receive will fail -> way to sleep
 (some-work)) ;; is exec'd cause spawn raises right away

(catch
  (lambda (exc) (list 'transfer-succeeds exc) )
  (spawn-link (raise 'err)) ;; caught and parent catch yields (list 'transfer-succeeds 'err)
  (? 1 'ok) ;; sleep
  (some-work)) ;; isn't exec'd
   #+end_src





*** Process Migration
 - node references as IP:ports needed
   #+begin_src scheme

(define migrating
  (spawn (let loop ()
           (recv ((from tag 'where)
                  (! from (list tag (current-node))))
                 (('migrate to)
                  (migrate to))))))

(define this (current-node))
(define that (make-node "<that's domain>" <thats port>))

(!? migrating 'where)                   ; spawned on this - yields this
(! migrating (list 'migrate that))      ; init's migration to that
(!? migrating 'where)                   ; yields that
(! migrating (list 'migrate this))      ; migrate back to this
(!? migrating 'where)                   ; back on this
   #+end_src
*** Remote Spawns
 - migrate after spawn

   #+begin_src scheme
(define node (make-node "domain.com" <port>))

(let ((this (self)))
  (spawn
   (migrate node)                       ; migrate the spawn
   (! this (list 'from node))))

(?)                                     ; recv `(from ,node)
   #+end_src

***
* Relevant Nodes
** [[id:f10899df-3d45-4290-bc50-b75c85bfb66b][Message Passing Computation]]
** [[id:d41dc898-8776-47bb-a88d-bc143250799f][Lisp Continuations]]
** [[id:f6111cb3-60df-422e-aca3-c4cb1b5cbb2a][Transparent Migration of Processes]]
** [[id:158b95bc-9434-48f2-b932-3be750afa7e6][Erlang]] + [[id:bc1ce0eb-26ce-4261-959f-7bb4b0fa38d4][scheme]]
** [[id:a4fd4495-8068-4824-8629-e5b2e5cdb906][Send and Pray]]
